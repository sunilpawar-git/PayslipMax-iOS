#!/bin/bash

# PayslipMax Technical Debt Trend Monitor
# Tracks architectural compliance over time and generates trend reports
# Part of Phase 4: Bulletproof Prevention System

set -e

# Configuration
METRICS_FILE=".architecture-metrics.json"
REPORT_DIR="architecture-reports"
TIMESTAMP=$(date +%s)
DATE=$(date)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure metrics directory exists
mkdir -p "$REPORT_DIR"

# Function to collect current metrics
collect_metrics() {
    echo -e "${BLUE}üìä Collecting architecture metrics...${NC}"

    local total_files=$(find PayslipMax -name "*.swift" | wc -l)
    local violation_files=$(find PayslipMax -name "*.swift" -exec sh -c 'test $(wc -l < "$1") -gt 300' _ {} \; -print 2>/dev/null | wc -l)
    local compliance_rate=$(echo "scale=2; ($total_files - $violation_files) * 100 / $total_files" | bc 2>/dev/null || echo "0")

    # Calculate quality score (simplified metric based on compliance)
    local quality_score=$(echo "scale=1; 70 + ($compliance_rate * 0.3)" | bc 2>/dev/null || echo "70")

    # Count async usage (positive indicator)
    local async_usage=$(grep -r "async\|await" PayslipMax/ --include="*.swift" 2>/dev/null | wc -l)

    # Count protocol abstractions (positive indicator)
    local protocol_count=$(grep -r "protocol.*{" PayslipMax/ --include="*.swift" 2>/dev/null | wc -l)

    # Count MVVM violations
    local mvvm_violations=$(find PayslipMax/Services -name "*.swift" -exec grep -l "import SwiftUI" {} \; 2>/dev/null | grep -v UIAppearanceService.swift | wc -l)

    # Count DispatchSemaphore usage (anti-pattern)
    local semaphore_usage=$(grep -r "DispatchSemaphore" PayslipMax/ --include="*.swift" 2>/dev/null | wc -l)

    # Find largest files for tracking
    local largest_files=$(find PayslipMax -name "*.swift" -exec sh -c 'echo "$(wc -l < "$1") $1"' _ {} \; | sort -nr | head -5 | while read size file; do
        echo "    {\"file\": \"$(basename "$file")\", \"path\": \"$file\", \"lines\": $size},"
    done | sed '$s/,$//')

    # Create JSON entry
    local json_entry=$(cat << EOF
{
  "timestamp": $TIMESTAMP,
  "date": "$DATE",
  "metrics": {
    "total_files": $total_files,
    "violation_files": $violation_files,
    "compliance_rate": $compliance_rate,
    "quality_score": $quality_score,
    "async_usage": $async_usage,
    "protocol_count": $protocol_count,
    "mvvm_violations": $mvvm_violations,
    "semaphore_usage": $semaphore_usage
  },
  "largest_files": [
$largest_files
  ]
}
EOF
    )

    # Append to metrics file (create array if new)
    if [ ! -f "$METRICS_FILE" ]; then
        echo "[]" > "$METRICS_FILE"
    fi

    # Add new entry to JSON array
    local temp_file=$(mktemp)
    jq ". += [$json_entry]" "$METRICS_FILE" > "$temp_file" && mv "$temp_file" "$METRICS_FILE"

    echo -e "${GREEN}‚úÖ Metrics collected and stored${NC}"
}

# Function to generate trend report
generate_trend_report() {
    echo -e "${BLUE}üìà Generating technical debt trend report...${NC}"

    if [ ! -f "$METRICS_FILE" ] || [ ! -s "$METRICS_FILE" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No historical data available. Collect metrics first.${NC}"
        return 1
    fi

    local report_file="$REPORT_DIR/debt-trend-$(date +%Y%m%d-%H%M%S).md"

    cat << EOF > "$report_file"
# PayslipMax Technical Debt Trend Report

**Generated**: $(date)
**Analysis Period**: $(jq -r 'if length > 0 then .[0].date + " to " + .[-1].date else "No data" end' "$METRICS_FILE")

## üìä Current Status

$(generate_current_status_section)

## üìà Compliance Trend

$(generate_compliance_trend)

## üèÜ Quality Score Evolution

$(generate_quality_trend)

## üö® Critical Files Tracking

$(generate_critical_files_section)

## üîç Architecture Health Indicators

$(generate_health_indicators)

## üìã Recommendations

$(generate_recommendations)

---
*Report generated by PayslipMax Architecture Quality System*
EOF

    echo -e "${GREEN}‚úÖ Trend report generated: $report_file${NC}"
    echo "$report_file"
}

# Function to generate current status section
generate_current_status_section() {
    local latest_entry=$(jq '.[-1]' "$METRICS_FILE" 2>/dev/null)

    if [ "$latest_entry" = "null" ]; then
        echo "No current data available."
        return
    fi

    local total_files=$(echo "$latest_entry" | jq -r '.metrics.total_files')
    local violation_files=$(echo "$latest_entry" | jq -r '.metrics.violation_files')
    local compliance_rate=$(echo "$latest_entry" | jq -r '.metrics.compliance_rate')
    local quality_score=$(echo "$latest_entry" | jq -r '.metrics.quality_score')

    cat << EOF
- **Total Swift Files**: $total_files
- **Files Exceeding 300 Lines**: $violation_files
- **Compliance Rate**: $compliance_rate%
- **Estimated Quality Score**: $quality_score/100
- **Status**: $([ "$violation_files" -eq 0 ] && echo "üü¢ EXCELLENT" || echo "üü° NEEDS ATTENTION")
EOF
}

# Function to generate compliance trend
generate_compliance_trend() {
    local entries=$(jq 'length' "$METRICS_FILE")

    if [ "$entries" -lt 2 ]; then
        echo "Insufficient data for trend analysis (need at least 2 data points)."
        return
    fi

    echo "| Date | Compliance Rate | Violation Files | Trend |"
    echo "|------|-----------------|-----------------|-------|"

    jq -r '.[-10:] | .[] | "\(.date | split(" ")[0]) | \(.metrics.compliance_rate)% | \(.metrics.violation_files) | TBD"' "$METRICS_FILE" | tail -10

    # Calculate trend
    local current_rate=$(jq -r '.[-1].metrics.compliance_rate' "$METRICS_FILE")
    local previous_rate=$(jq -r '.[-2].metrics.compliance_rate' "$METRICS_FILE")
    local trend=$(echo "$current_rate - $previous_rate" | bc 2>/dev/null || echo "0")

    echo ""
    if (( $(echo "$trend > 0" | bc -l 2>/dev/null || echo 0) )); then
        echo "üìà **Improving**: +$trend% compliance since last measurement"
    elif (( $(echo "$trend < 0" | bc -l 2>/dev/null || echo 0) )); then
        echo "üìâ **Declining**: $trend% compliance since last measurement"
    else
        echo "‚û°Ô∏è  **Stable**: No change in compliance rate"
    fi
}

# Function to generate quality trend
generate_quality_trend() {
    echo "Quality Score History (Last 10 measurements):"
    echo ""
    jq -r '.[-10:] | .[] | "- \(.date | split(" ")[0]): \(.metrics.quality_score)/100"' "$METRICS_FILE"

    # Check if we're meeting the 94+ target
    local current_score=$(jq -r '.[-1].metrics.quality_score' "$METRICS_FILE")
    if (( $(echo "$current_score >= 94" | bc -l 2>/dev/null || echo 0) )); then
        echo ""
        echo "üéØ **Target Achievement**: Quality score meets 94+/100 requirement"
    else
        local gap=$(echo "94 - $current_score" | bc 2>/dev/null || echo "N/A")
        echo ""
        echo "üìä **Gap to Target**: $gap points needed to reach 94/100"
    fi
}

# Function to generate critical files section
generate_critical_files_section() {
    echo "Files consistently appearing in largest files list:"
    echo ""

    # Extract all files from historical data and count occurrences
    jq -r '.[] | .largest_files[] | .file' "$METRICS_FILE" 2>/dev/null | sort | uniq -c | sort -nr | head -10 | while read count file; do
        echo "- **$file**: Appeared in $count measurements"
    done
}

# Function to generate health indicators
generate_health_indicators() {
    local latest=$(jq '.[-1].metrics' "$METRICS_FILE" 2>/dev/null)

    if [ "$latest" = "null" ]; then
        echo "No health data available."
        return
    fi

    local async_usage=$(echo "$latest" | jq -r '.async_usage')
    local protocol_count=$(echo "$latest" | jq -r '.protocol_count')
    local mvvm_violations=$(echo "$latest" | jq -r '.mvvm_violations')
    local semaphore_usage=$(echo "$latest" | jq -r '.semaphore_usage')

    cat << EOF
| Indicator | Value | Status |
|-----------|-------|--------|
| Async/Await Usage | $async_usage | $([ "$async_usage" -gt 100 ] && echo "üü¢ Good" || echo "üü° Improving") |
| Protocol Abstractions | $protocol_count | $([ "$protocol_count" -gt 50 ] && echo "üü¢ Good" || echo "üü° Moderate") |
| MVVM Violations | $mvvm_violations | $([ "$mvvm_violations" -eq 0 ] && echo "üü¢ Excellent" || echo "üî¥ Needs Fix") |
| DispatchSemaphore Usage | $semaphore_usage | $([ "$semaphore_usage" -eq 0 ] && echo "üü¢ Excellent" || echo "üî¥ Remove ASAP") |
EOF
}

# Function to generate recommendations
generate_recommendations() {
    local violation_files=$(jq -r '.[-1].metrics.violation_files' "$METRICS_FILE" 2>/dev/null || echo "0")
    local mvvm_violations=$(jq -r '.[-1].metrics.mvvm_violations' "$METRICS_FILE" 2>/dev/null || echo "0")
    local semaphore_usage=$(jq -r '.[-1].metrics.semaphore_usage' "$METRICS_FILE" 2>/dev/null || echo "0")

    echo "### Priority Actions"
    echo ""

    if [ "$violation_files" -gt 0 ]; then
        echo "1. **üö® HIGH PRIORITY**: Refactor $violation_files files exceeding 300 lines"
        echo "   - Run \`./Scripts/component-extraction-helper.sh\` for guidance"
        echo "   - Follow established refactoring patterns from Phase 3"
        echo ""
    fi

    if [ "$mvvm_violations" -gt 0 ]; then
        echo "2. **üèóÔ∏è ARCHITECTURE**: Fix $mvvm_violations MVVM violations"
        echo "   - Remove SwiftUI imports from Services"
        echo "   - Use protocol-based dependency injection"
        echo ""
    fi

    if [ "$semaphore_usage" -gt 0 ]; then
        echo "3. **‚ö° ASYNC COMPLIANCE**: Remove $semaphore_usage DispatchSemaphore usages"
        echo "   - Replace with async/await patterns"
        echo "   - Use TaskGroup for parallel processing"
        echo ""
    fi

    if [ "$violation_files" -eq 0 ] && [ "$mvvm_violations" -eq 0 ] && [ "$semaphore_usage" -eq 0 ]; then
        echo "üéâ **Excellent!** All critical metrics are within acceptable ranges."
        echo ""
        echo "### Maintenance Recommendations"
        echo "- Continue monitoring file sizes during development"
        echo "- Maintain async-first development practices"
        echo "- Regular architecture quality reviews"
    fi
}

# Function to show summary dashboard
show_dashboard() {
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë                    PayslipMax Architecture Dashboard         ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    if [ ! -f "$METRICS_FILE" ] || [ ! -s "$METRICS_FILE" ]; then
        echo -e "${YELLOW}üìä No metrics data available. Run with --collect to start tracking.${NC}"
        return
    fi

    local latest=$(jq '.[-1]' "$METRICS_FILE" 2>/dev/null)
    local compliance_rate=$(echo "$latest" | jq -r '.metrics.compliance_rate')
    local violation_files=$(echo "$latest" | jq -r '.metrics.violation_files')
    local quality_score=$(echo "$latest" | jq -r '.metrics.quality_score')

    echo -e "${BLUE}üìà Current Status${NC}"
    echo "   Compliance Rate: $compliance_rate%"
    echo "   Violation Files: $violation_files"
    echo "   Quality Score: $quality_score/100"
    echo ""

    # Status indicator
    if [ "$violation_files" -eq 0 ]; then
        echo -e "${GREEN}üéØ STATUS: EXCELLENT - All files comply with 300-line rule${NC}"
    elif [ "$violation_files" -le 5 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  STATUS: GOOD - Minor violations, focus on top files${NC}"
    else
        echo -e "${RED}üö® STATUS: ATTENTION NEEDED - Multiple violations require action${NC}"
    fi

    echo ""
    echo -e "${BLUE}üìä Recent Measurements: $(jq 'length' "$METRICS_FILE")${NC}"
    echo -e "${BLUE}üóìÔ∏è  Last Updated: $(echo "$latest" | jq -r '.date')${NC}"
}

# Function to cleanup old data
cleanup_old_data() {
    local keep_days=${1:-30}
    local cutoff_timestamp=$(($(date +%s) - (keep_days * 24 * 3600)))

    echo -e "${BLUE}üßπ Cleaning up data older than $keep_days days...${NC}"

    if [ -f "$METRICS_FILE" ]; then
        local temp_file=$(mktemp)
        jq "[.[] | select(.timestamp > $cutoff_timestamp)]" "$METRICS_FILE" > "$temp_file" && mv "$temp_file" "$METRICS_FILE"
        echo -e "${GREEN}‚úÖ Cleanup complete${NC}"
    fi

    # Cleanup old report files
    find "$REPORT_DIR" -name "debt-trend-*.md" -mtime +$keep_days -delete 2>/dev/null || true
}

# Main function
main() {
    case "$1" in
        --collect)
            collect_metrics
            ;;
        --report)
            report_file=$(generate_trend_report)
            echo -e "${GREEN}üìÑ Report generated: $report_file${NC}"
            ;;
        --dashboard)
            show_dashboard
            ;;
        --cleanup)
            cleanup_old_data "${2:-30}"
            ;;
        --help)
            cat << EOF
PayslipMax Technical Debt Trend Monitor

Usage: $0 [--collect|--report|--dashboard|--cleanup [days]|--help]

Commands:
  --collect      Collect current architecture metrics
  --report       Generate detailed trend report
  --dashboard    Show current status dashboard
  --cleanup      Clean up old data (default: 30 days)
  --help         Show this help message

Examples:
  $0 --collect                    # Collect current metrics
  $0 --report                     # Generate trend report
  $0 --dashboard                  # Show current status
  $0 --cleanup 14                 # Keep only last 14 days of data

Note: Run --collect regularly (e.g., daily) to track trends over time.
EOF
            ;;
        *)
            echo -e "${BLUE}üîç PayslipMax Technical Debt Monitor${NC}"
            echo "Usage: $0 [--collect|--report|--dashboard|--cleanup|--help]"
            echo "Run '$0 --help' for detailed usage information."
            ;;
    esac
}

# Ensure jq is available
if ! command -v jq &> /dev/null; then
    echo -e "${RED}‚ùå Error: jq is required but not installed${NC}"
    echo "Install with: brew install jq"
    exit 1
fi

# Ensure bc is available
if ! command -v bc &> /dev/null; then
    echo -e "${RED}‚ùå Error: bc is required but not installed${NC}"
    echo "Install with: brew install bc"
    exit 1
fi

# Execute main function
main "$@"
