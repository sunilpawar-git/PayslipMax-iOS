import Foundation

/// Protocol for Payslip Formatter Service to enable dependency injection
@MainActor
protocol PayslipFormatterServiceProtocol {
    /// Formats a value as a currency string
    func formatCurrency(_ value: Double?) -> String

    /// Formats a year value without group separators
    func formatYear(_ year: Int) -> String

    /// Gets a formatter for currency values
    func getCurrencyFormatter() -> NumberFormatter

    /// Gets a formatted string representation of the payslip for sharing
    func getShareText(for payslipData: PayslipData) -> String
}

/// Service for formatting payslip data for display and sharing
/// Now supports both singleton and dependency injection patterns
@MainActor
class PayslipFormatterService: PayslipFormatterServiceProtocol, @preconcurrency SafeConversionProtocol {
    // MARK: - Singleton Instance
    static let shared = PayslipFormatterService()

    /// Current conversion state
    var conversionState: ConversionState = .singleton

    /// Initialize with dependency injection support
    /// - Parameter dependencies: Optional dependencies (none required for this service)
    init(dependencies: [String: Any] = [:]) {
        // No dependencies required for formatting service
    }

    // MARK: - Formatting Methods

    /// Formats a value as a currency string.
    ///
    /// - Parameter value: The value to format.
    /// - Returns: A formatted currency string.
    func formatCurrency(_ value: Double?) -> String {
        guard let value = value else { return "₹0" }

        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "₹"
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 0
        formatter.usesGroupingSeparator = true

        if let formattedValue = formatter.string(from: NSNumber(value: value)) {
            return formattedValue
        }

        return "₹\(Int(value))"
    }

    /// Formats a year value without group separators
    func formatYear(_ year: Int) -> String {
        return "\(year)" // Simple string conversion without formatting
    }

    /// Gets a formatter for currency values
    func getCurrencyFormatter() -> NumberFormatter {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "₹"
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 0
        formatter.usesGroupingSeparator = true
        return formatter
    }

    /// Gets a formatted string representation of the payslip for sharing.
    ///
    /// - Returns: A formatted string with payslip details.
    func getShareText(for payslipData: PayslipData) -> String {
        // Create a formatted description from PayslipData
        let formatter = getCurrencyFormatter()

        let creditsStr = formatter.string(from: NSNumber(value: payslipData.totalCredits)) ?? "\(payslipData.totalCredits)"
        let debitsStr = formatter.string(from: NSNumber(value: payslipData.totalDebits)) ?? "\(payslipData.totalDebits)"
        let dsopStr = formatter.string(from: NSNumber(value: payslipData.dsop)) ?? "\(payslipData.dsop)"
        let taxStr = formatter.string(from: NSNumber(value: payslipData.incomeTax)) ?? "\(payslipData.incomeTax)"
        let netStr = formatter.string(from: NSNumber(value: payslipData.netRemittance)) ?? "\(payslipData.netRemittance)"

        var description = """
        PAYSLIP DETAILS
        ---------------

        PERSONAL DETAILS:
        Name: \(payslipData.name)
        Month: \(payslipData.month)
        Year: \(payslipData.year)

        FINANCIAL DETAILS:
        Credits: \(creditsStr)
        Debits: \(debitsStr)
        DSOP: \(dsopStr)
        Tax: \(taxStr)
        Net Amount: \(netStr)
        """

        // Add earnings breakdown if available
        if !payslipData.allEarnings.isEmpty {
            description += "\n\nEARNINGS BREAKDOWN:"
            for (key, value) in payslipData.allEarnings.sorted(by: { $0.key < $1.key }) {
                if value > 0 {
                    let valueStr = formatter.string(from: NSNumber(value: value)) ?? "\(value)"
                    description += "\n\(key): \(valueStr)"
                }
            }
        }

        // Add deductions breakdown if available
        if !payslipData.allDeductions.isEmpty {
            description += "\n\nDEDUCTIONS BREAKDOWN:"
            for (key, value) in payslipData.allDeductions.sorted(by: { $0.key < $1.key }) {
                if value > 0 {
                    let valueStr = formatter.string(from: NSNumber(value: value)) ?? "\(value)"
                    description += "\n\(key): \(valueStr)"
                }
            }
        }

        description += "\n\nGenerated by PayslipMax"

        return description
    }

    // MARK: - SafeConversionProtocol Implementation

    /// Validates that the service can be safely converted to DI
    func validateConversionSafety() async -> Bool {
        // Payslip formatter service has no external dependencies, safe to convert
        return true
    }

    /// Validates dependencies are properly injected and functional
    func validateDependencies() async -> DependencyValidationResult {
        // Payslip formatter service has no external dependencies
        return DependencyValidationResult.success
    }

    /// Creates a new instance via dependency injection
    func createDIInstance(dependencies: [String: Any]) -> Self? {
        return PayslipFormatterService(dependencies: dependencies) as? Self
    }

    /// Performs the conversion from singleton to DI pattern
    func performConversion(container: any DIContainerProtocol) async -> Bool {
        await MainActor.run {
            conversionState = .converting
            ConversionTracker.shared.updateConversionState(for: PayslipFormatterService.self, state: .converting)
        }

        // Note: Integration with existing DI architecture will be handled separately
        // This method validates the conversion is safe and updates tracking

        await MainActor.run {
            conversionState = .dependencyInjected
            ConversionTracker.shared.updateConversionState(for: PayslipFormatterService.self, state: .dependencyInjected)
        }

        Logger.info("Successfully converted PayslipFormatterService to DI pattern", category: "PayslipFormatterService")
        return true
    }

    /// Rolls back to singleton pattern if issues are detected
    func rollbackConversion() async -> Bool {
        await MainActor.run {
            conversionState = .singleton
            ConversionTracker.shared.updateConversionState(for: PayslipFormatterService.self, state: .singleton)
        }
        Logger.info("Rolled back PayslipFormatterService to singleton pattern", category: "PayslipFormatterService")
        return true
    }

    /// Returns the singleton instance (fallback mode)
    static func sharedInstance() -> Self {
        return shared as! Self
    }

    /// Determines whether to use DI or singleton based on feature flags
}
