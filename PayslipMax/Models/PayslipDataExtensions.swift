import Foundation
import PDFKit

// MARK: - PayslipData Extensions

extension PayslipData {
    // MARK: - Calculated Properties
    /// The calculated net income (Total Credits - Total Debits).
    var netIncome: Double {
        return totalCredits - totalDebits
    }

    // MARK: - PayslipEncryptionProtocol Methods
    /// No-op encryption method for the `PayslipData` value type.
    /// Encryption is typically handled by the persistent `PayslipItem` model.
    func encryptSensitiveData() async throws {
        // No-op for now since this is a value type
    }

    /// No-op decryption method for the `PayslipData` value type.
    /// Decryption is typically handled by the persistent `PayslipItem` model.
    func decryptSensitiveData() async throws {
        // No-op for now since this is a value type
    }

    // MARK: - PayslipMetadataProtocol Computed Properties
    var pdfDocument: PDFDocument? {
        guard let data = pdfData else { return nil }
        return PDFDocument(data: data)
    }

    // MARK: - PayslipProtocol Methods
    /// Generates a detailed, formatted string description of the payslip data.
    /// Includes personal details, financial summary, and breakdowns of earnings and deductions.
    /// - Returns: A multi-line string describing the payslip.
    func getFullDescription() -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencySymbol = "â‚¹"
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 0
        formatter.usesGroupingSeparator = true

        let creditsStr = formatter.string(from: NSNumber(value: credits)) ?? "\(credits)"
        let debitsStr = formatter.string(from: NSNumber(value: debits)) ?? "\(debits)"
        let dsopStr = formatter.string(from: NSNumber(value: dsop)) ?? "\(dsop)"
        let taxStr = formatter.string(from: NSNumber(value: tax)) ?? "\(tax)"
        let netStr = formatter.string(from: NSNumber(value: calculateNetAmount())) ?? "\(calculateNetAmount())"

        var description = """
        PAYSLIP DETAILS
        ---------------

        PERSONAL DETAILS:
        Name: \(name)
        Month: \(month)
        Year: \(year)

        FINANCIAL DETAILS:
        Credits: \(creditsStr)
        Debits: \(debitsStr)
        DSOP: \(dsopStr)
        Tax: \(taxStr)
        Net Amount: \(netStr)
        """

        // Add earnings breakdown if available
        if !earnings.isEmpty {
            description += "\n\nEARNINGS BREAKDOWN:"
            for (key, value) in earnings.sorted(by: { $0.key < $1.key }) {
                if value > 0 {
                    let valueStr = formatter.string(from: NSNumber(value: value)) ?? "\(value)"
                    description += "\n\(key): \(valueStr)"
                }
            }
        }

        // Add deductions breakdown if available
        if !deductions.isEmpty {
            description += "\n\nDEDUCTIONS BREAKDOWN:"
            for (key, value) in deductions.sorted(by: { $0.key < $1.key }) {
                if value > 0 {
                    let valueStr = formatter.string(from: NSNumber(value: value)) ?? "\(value)"
                    description += "\n\(key): \(valueStr)"
                }
            }
        }

        description += "\n\nGenerated by PayslipMax"

        return description
    }

    // MARK: - Helper Methods
    /// Calculates the net amount (credits - debits).
    /// This uses the primary `credits` and `debits` properties conforming to `PayslipDataProtocol`.
    /// - Returns: The calculated net amount.
    func calculateNetAmount() -> Double {
        return credits - debits
    }

    /// Calculates derived financial fields based on detailed earnings and deductions.
    /// Populates `totalCredits`, `totalDebits`, and `netRemittance` if they are zero.
    /// Updates the `credits`, `debits`, `earnings`, and `deductions` properties required by `PayslipProtocol`.
    mutating func calculateDerivedFields() {
        // If any values are missing, try to calculate them
        if totalCredits == 0 && !allEarnings.isEmpty {
            totalCredits = allEarnings.values.reduce(0, +)
        }

        if totalDebits == 0 && !allDeductions.isEmpty {
            totalDebits = allDeductions.values.reduce(0, +)
        }

        if netRemittance == 0 {
            netRemittance = totalCredits - totalDebits
        }

        // Update credits and debits to match protocol requirements
        credits = totalCredits
        debits = totalDebits

        // Update earnings and deductions dictionaries
        earnings = allEarnings
        deductions = allDeductions
    }

    /// Indicates whether all sensitive fields (`name`, `accountNumber`, `panNumber`) are marked as encrypted.
    var isFullyEncrypted: Bool {
        return isNameEncrypted && isAccountNumberEncrypted && isPanNumberEncrypted
    }

    // MARK: - Convenience Methods
    /// Get the net amount using the protocol method
    func getNetAmount() -> Double {
        return calculateNetAmount()
    }

    /// Get the total tax amount
    func getTotalTax() -> Double {
        return tax
    }
}
